import { logger } from '../../utils/logger';
import { MapTile, TerrainType, TerrainProperty } from './MapTypes';

/**
 * River map state tracking for sophisticated river generation
 * @reference freeciv/server/generator/mapgen.c:115-118
 */
export interface RiverMapState {
  blocked: Set<number>; // Tiles marked as blocked for river placement
  ok: Set<number>; // Tiles marked as valid river tiles
}

/**
 * River type definition (equivalent to freeciv extra_type with RF_RIVER flag)
 * @reference freeciv/server/generator/mapgen.c:73-74
 */
interface RiverType {
  id: string;
  name: string;
  generated: boolean; // Can be generated by map generator
}

/**
 * Wetness condition enumeration
 * @reference freeciv/server/generator/mapgen.c:169-174
 */
enum WetnessCondition {
  WC_ALL = 0, // No wetness restriction
  WC_DRY = 1, // Dry areas only
  WC_NDRY = 2, // Non-dry areas only
}

/**
 * Temperature type enumeration
 * @reference freeciv/server/generator/mapgen.c:176-181
 */
enum TemperatureType {
  TT_ALL = 0, // No temperature restriction
  TT_FROZEN = 1, // Frozen areas only
  TT_NFROZEN = 2, // Non-frozen areas only
  TT_HOT = 3, // Hot areas only
  TT_NHOT = 4, // Non-hot areas only
  TT_COLD = 5, // Cold areas only
}

/**
 * Miscellaneous condition enumeration
 * @reference freeciv/server/generator/mapgen.c:183-196
 */
enum MiscellaneousCondition {
  MC_NONE = 0, // No special condition
  MC_LOW = 1, // Low elevation areas
  MC_NLOW = 2, // Non-low elevation areas
}

/**
 * Placed map system for tracking generated tiles
 * @reference freeciv/server/generator/mapgen_utils.c:48-82
 */
class PlacedMapSystem {
  private placedMap: boolean[] = [];
  private mapSize: number;

  constructor(mapSize: number) {
    this.mapSize = mapSize;
  }

  create(): void {
    this.placedMap = new Array(this.mapSize).fill(false);
  }

  destroy(): void {
    this.placedMap = [];
  }

  isPlaced(tileIndex: number): boolean {
    return this.placedMap[tileIndex] || false;
  }

  setPlaced(tileIndex: number): void {
    this.placedMap[tileIndex] = true;
  }

  setAllOceanPlaced(tiles: MapTile[][], width: number): void {
    for (let x = 0; x < tiles.length; x++) {
      for (let y = 0; y < tiles[x].length; y++) {
        const tile = tiles[x][y];
        if (!this.isLandTile(tile.terrain)) {
          const tileIndex = y * width + x;
          this.setPlaced(tileIndex);
        }
      }
    }
  }

  private isLandTile(terrain: TerrainType): boolean {
    return !['ocean', 'coast', 'deep_ocean', 'lake'].includes(terrain);
  }
}

export class RiverGenerator {
  private width: number;
  private height: number;
  private random: () => number;
  private riverTypes: RiverType[] = [];
  private placedMapSystem: PlacedMapSystem;
  private readonly RIVERS_MAXTRIES = 32767; // @reference freeciv/server/generator/mapgen.c

  constructor(width: number, height: number, random: () => number) {
    this.width = width;
    this.height = height;
    this.random = random;
    this.placedMapSystem = new PlacedMapSystem(width * height);
    this.initializeRiverTypes();
  }

  /**
   * Initialize available river types (equivalent to river_types_init)
   * @reference freeciv/server/generator/mapgen.c:2509-2519
   */
  private initializeRiverTypes(): void {
    // In freeciv, this searches for extra_type with RF_RIVER flag
    // For our implementation, we'll define the standard river type
    this.riverTypes = [
      {
        id: 'river',
        name: 'River',
        generated: true,
      },
    ];
  }

  /**
   * Generate advanced river system using freeciv algorithm
   * @reference freeciv/server/generator/mapgen.c:906-1046 make_rivers()
   */
  public async generateAdvancedRivers(tiles: MapTile[][], riverPct: number): Promise<void> {
    logger.info(`Starting advanced river generation with ${riverPct.toFixed(1)}% target density`);
    const startTime = Date.now();

    // Check if river types are available (freeciv lines 934-937)
    if (this.riverTypes.length <= 0) {
      logger.warn('No river type available - skipping river generation');
      return;
    }

    // Create placed map (freeciv lines 939-940)
    this.placedMapSystem.create();
    this.placedMapSystem.setAllOceanPlaced(tiles, this.width);

    // Create river map state (freeciv lines 942-943)
    const riverMap: RiverMapState = {
      blocked: new Set<number>(),
      ok: new Set<number>(),
    };

    // FREECIV ALGORITHM: Calculate desirable river length using exact formula
    // @reference freeciv/server/generator/mapgen.c:915-924
    const mapNumTiles = this.width * this.height;
    const landPercent = this.calculateLandPercent(tiles);
    const desirableRiverLength = Math.floor((riverPct * mapNumTiles * landPercent) / 5325);

    // The number of river tiles that have been set (freeciv line 927)
    let currentRiverLength = 0;

    // Iteration counter (freeciv lines 929-932)
    let iterationCounter = 0;

    logger.info(
      `Target river length: ${desirableRiverLength} tiles (${riverPct}% of ${mapNumTiles} tiles * ${landPercent}% land / 5325)`
    );

    // FREECIV MAIN LOOP: Exactly matches freeciv/server/generator/mapgen.c:946-1040
    while (currentRiverLength < desirableRiverLength && iterationCounter < this.RIVERS_MAXTRIES) {
      // Find candidate spring location using rand_map_pos_characteristic (freeciv lines 949-952)
      const springTile = this.randMapPosCharacteristic(
        tiles,
        WetnessCondition.WC_ALL,
        TemperatureType.TT_NFROZEN,
        MiscellaneousCondition.MC_NONE // Allow any elevation for now - TODO: Fix terrain property calculation
      );
      if (!springTile) {
        break; // No more spring places
      }

      // Check if it is suitable to start a river (freeciv lines 955-990)
      if (
        this.isSuitableRiverStart(springTile.x, springTile.y, tiles, riverMap, iterationCounter)
      ) {
        // Reset river map before making a new river (freeciv lines 993-994)
        riverMap.blocked.clear();
        riverMap.ok.clear();

        // Select random river type (freeciv line 996)
        const riverType = this.riverTypes[Math.floor(this.random() * this.riverTypes.length)];

        // Block existing rivers of different types (freeciv lines 998-1006)
        this.blockExistingRivers(tiles, riverMap, riverType);

        logger.debug(
          `Found suitable starting tile for river at (${springTile.x}, ${springTile.y}). Starting to make it.`
        );

        // Try to make a river. If it is OK, apply it to the map (freeciv lines 1012-1030)
        if (this.makeRiver(springTile.x, springTile.y, tiles, riverMap, riverType)) {
          const riverTilesApplied = this.applyRiverMapToTiles(tiles, riverMap, riverType);
          currentRiverLength += riverTilesApplied;
        } else {
          logger.debug('A river failed. It might have gotten stuck in a helix.');
        }
      }

      // Always increment iteration counter (freeciv line 1036)
      iterationCounter++;

      // Debug logging (freeciv lines 1037-1039)
      if (iterationCounter % 1000 === 0) {
        logger.debug(
          `current_riverlength: ${currentRiverLength}; desirable_riverlength: ${desirableRiverLength}; iteration_counter: ${iterationCounter}`
        );
      }
    }

    // Cleanup (freeciv lines 1042-1045)
    this.placedMapSystem.destroy();

    const endTime = Date.now();
    const landTiles = tiles.flat().filter(tile => this.isLandTile(tile.terrain)).length;
    const actualRiverPct = landTiles > 0 ? (currentRiverLength / landTiles) * 100 : 0;
    logger.info(
      `Advanced river generation completed: ${currentRiverLength}/${desirableRiverLength} river tiles (${actualRiverPct.toFixed(1)}% density) in ${iterationCounter} iterations, ${endTime - startTime}ms`
    );
  }

  /**
   * Calculate land percentage for freeciv formula
   * @reference freeciv/server/generator/mapgen.c:920 wld.map.server.landpercent
   */
  private calculateLandPercent(tiles: MapTile[][]): number {
    const totalTiles = this.width * this.height;
    const landTiles = tiles.flat().filter(tile => this.isLandTile(tile.terrain)).length;
    return Math.floor((landTiles / totalTiles) * 100);
  }

  /**
   * Equivalent to freeciv's rand_map_pos_characteristic()
   * @reference freeciv/server/generator/mapgen.c:265-272
   */
  private randMapPosCharacteristic(
    tiles: MapTile[][],
    wc: WetnessCondition,
    tc: TemperatureType,
    mc: MiscellaneousCondition
  ): { x: number; y: number } | null {
    const maxAttempts = 2000; // Reasonable limit to prevent infinite loops
    let attempts = 0;

    while (attempts < maxAttempts) {
      const x = Math.floor(this.random() * this.width);
      const y = Math.floor(this.random() * this.height);
      const tileIndex = y * this.width + x;

      // Skip if already placed
      if (this.placedMapSystem.isPlaced(tileIndex)) {
        attempts++;
        continue;
      }

      if (this.conditionFilter(x, y, tiles, wc, tc, mc)) {
        return { x, y };
      }

      attempts++;
    }

    return null; // No suitable position found
  }

  /**
   * Filter function for terrain characteristics
   * @reference freeciv/server/generator/mapgen.c condition_filter logic
   */
  private conditionFilter(
    x: number,
    y: number,
    tiles: MapTile[][],
    wc: WetnessCondition,
    tc: TemperatureType,
    mc: MiscellaneousCondition
  ): boolean {
    const tile = tiles[x][y];

    // Wetness condition check
    if (wc !== WetnessCondition.WC_ALL) {
      const dry = tile.properties[TerrainProperty.DRY] || 0;
      if (wc === WetnessCondition.WC_DRY && dry < 50) return false;
      if (wc === WetnessCondition.WC_NDRY && dry >= 50) return false;
    }

    // Temperature condition check
    if (tc !== TemperatureType.TT_ALL) {
      const frozen = tile.properties[TerrainProperty.FROZEN] || 0;
      const tempHot = (tile.temperature || 50) > 70; // Simplified hot check
      const tempCold = (tile.temperature || 50) < 30; // Simplified cold check

      switch (tc) {
        case TemperatureType.TT_FROZEN:
          if (frozen < 50) return false;
          break;
        case TemperatureType.TT_NFROZEN:
          if (frozen >= 50) return false;
          break;
        case TemperatureType.TT_HOT:
          if (!tempHot) return false;
          break;
        case TemperatureType.TT_NHOT:
          if (tempHot) return false;
          break;
        case TemperatureType.TT_COLD:
          if (!tempCold) return false;
          break;
      }
    }

    // Miscellaneous condition check
    if (mc !== MiscellaneousCondition.MC_NONE) {
      const mountainous = tile.properties[TerrainProperty.MOUNTAINOUS] || 0;
      const isLow = mountainous < 30; // Simplified elevation check

      if (mc === MiscellaneousCondition.MC_LOW && !isLow) return false;
      if (mc === MiscellaneousCondition.MC_NLOW && isLow) return false;
    }

    return true;
  }

  /**
   * Check if it is suitable to start a river on the current tile
   * @reference freeciv/server/generator/mapgen.c:955-990
   */
  private isSuitableRiverStart(
    x: number,
    y: number,
    tiles: MapTile[][],
    _riverMap: RiverMapState,
    iterationCounter: number
  ): boolean {
    const tile = tiles[x][y];
    const terrain = tile.terrain;

    // Don't start a river on ocean (freeciv line 959)
    if (!this.isLandTile(terrain)) {
      return false;
    }

    // Don't start a river on river (freeciv line 962)
    if (tile.riverMask && tile.riverMask > 0) {
      return false;
    }

    // Don't start a river on a tile surrounded by > 1 river + ocean tile (freeciv lines 964-968)
    const nearbyRivers = this.countRiverNearTile(x, y, tiles);
    const nearbyOcean = this.countOceanNearTile(x, y, tiles);
    if (nearbyRivers + nearbyOcean > 1) {
      return false;
    }

    // Get terrain properties
    const mountainous = tile.properties[TerrainProperty.MOUNTAINOUS] || 0;
    const frozen = tile.properties[TerrainProperty.FROZEN] || 0;
    const dry = tile.properties[TerrainProperty.DRY] || 0;

    // Don't start a river on a tile that is surrounded by hills or mountains
    // unless it is hard to find somewhere else to start it (freeciv lines 970-975)
    const nearbyMountainous = this.countMountainousNearTile(x, y, tiles);
    if (nearbyMountainous >= 90 && iterationCounter < Math.floor((this.RIVERS_MAXTRIES / 10) * 5)) {
      return false;
    }

    // Don't start a river on hills unless it is hard to find somewhere else (freeciv lines 977-980)
    if (mountainous > 0 && iterationCounter < Math.floor((this.RIVERS_MAXTRIES / 10) * 6)) {
      return false;
    }

    // Don't start a river on arctic unless it is hard to find somewhere else (freeciv lines 982-985)
    if (frozen > 0 && iterationCounter < Math.floor((this.RIVERS_MAXTRIES / 10) * 8)) {
      return false;
    }

    // Don't start a river on desert unless it is hard to find somewhere else (freeciv lines 987-990)
    if (dry > 0 && iterationCounter < Math.floor((this.RIVERS_MAXTRIES / 10) * 9)) {
      return false;
    }

    return true;
  }

  /**
   * @reference freeciv/server/generator/mapgen.c:998-1006
   */
  private blockExistingRivers(
    tiles: MapTile[][],
    riverMap: RiverMapState,
    _currentRiverType: RiverType
  ): void {
    // In freeciv, this iterates over all river types and blocks tiles with different river types
    // For our simplified implementation, we block all existing rivers
    for (let x = 0; x < this.width; x++) {
      for (let y = 0; y < this.height; y++) {
        const tile = tiles[x][y];
        if (tile.riverMask && tile.riverMask > 0) {
          const tileIndex = y * this.width + x;
          riverMap.blocked.add(tileIndex);
        }
      }
    }
  }

  /**
   * Count rivers near tile (freeciv: count_river_near_tile)
   */
  private countRiverNearTile(x: number, y: number, tiles: MapTile[][]): number {
    let count = 0;
    const cardinalDirs = [
      { dx: 0, dy: -1 },
      { dx: 1, dy: 0 },
      { dx: 0, dy: 1 },
      { dx: -1, dy: 0 },
    ];

    for (const dir of cardinalDirs) {
      const nx = x + dir.dx;
      const ny = y + dir.dy;
      if (nx >= 0 && nx < this.width && ny >= 0 && ny < this.height) {
        if (tiles[nx][ny].riverMask && tiles[nx][ny].riverMask > 0) {
          count++;
        }
      }
    }
    return count;
  }

  /**
   * Count ocean tiles near tile (freeciv: count_terrain_class_near_tile)
   */
  private countOceanNearTile(x: number, y: number, tiles: MapTile[][]): number {
    let count = 0;
    const cardinalDirs = [
      { dx: 0, dy: -1 },
      { dx: 1, dy: 0 },
      { dx: 0, dy: 1 },
      { dx: -1, dy: 0 },
    ];

    for (const dir of cardinalDirs) {
      const nx = x + dir.dx;
      const ny = y + dir.dy;
      if (nx >= 0 && nx < this.width && ny >= 0 && ny < this.height) {
        if (!this.isLandTile(tiles[nx][ny].terrain)) {
          count++;
        }
      }
    }
    return count;
  }

  /**
   * Count mountainous terrain near tile (freeciv: count_terrain_property_near_tile)
   */
  private countMountainousNearTile(x: number, y: number, tiles: MapTile[][]): number {
    let totalMountainous = 0;
    const cardinalDirs = [
      { dx: 0, dy: -1 },
      { dx: 1, dy: 0 },
      { dx: 0, dy: 1 },
      { dx: -1, dy: 0 },
    ];

    for (const dir of cardinalDirs) {
      const nx = x + dir.dx;
      const ny = y + dir.dy;
      if (nx >= 0 && nx < this.width && ny >= 0 && ny < this.height) {
        const mountainous = tiles[nx][ny].properties[TerrainProperty.MOUNTAINOUS] || 0;
        totalMountainous += mountainous;
      }
    }
    return totalMountainous;
  }

  /**
   * Apply river tiles from riverMap to actual map tiles
   * @reference freeciv/server/generator/mapgen.c:1013-1030
   */
  private applyRiverMapToTiles(
    tiles: MapTile[][],
    riverMap: RiverMapState,
    _riverType: RiverType
  ): number {
    let tilesApplied = 0;

    // Iterate through all tiles marked as river in rivermap.ok (freeciv lines 1013-1030)
    for (const tileIndex of riverMap.ok) {
      const x = tileIndex % this.width;
      const y = Math.floor(tileIndex / this.width);

      if (x >= 0 && x < this.width && y >= 0 && y < this.height) {
        const tile = tiles[x][y];

        // Check if terrain can have rivers (freeciv lines 1017-1023)
        if (!this.terrainCanHaveRiver(tile.terrain)) {
          // Change terrain to one that can have rivers
          const newTerrain = this.pickTerrainForRiver(tile.terrain);
          tile.terrain = newTerrain;
        }

        // Add river to tile (freeciv line 1025)
        const riverMask = this.generateRiverMask(x, y, tiles, riverMap);
        tile.riverMask = riverMask;

        // Mark as placed (freeciv line 1027)
        this.placedMapSystem.setPlaced(tileIndex);

        // Increment river length counter (freeciv line 1026)
        tilesApplied++;

        logger.debug(`Applied a river to (${x}, ${y}).`);
      }
    }

    return tilesApplied;
  }

  /**
   * Check if terrain can have rivers
   */
  private terrainCanHaveRiver(terrain: TerrainType): boolean {
    // Most land terrains can have rivers, except some special cases
    return this.isLandTile(terrain) && terrain !== 'mountains';
  }

  /**
   * Pick suitable terrain for river placement
   */
  private pickTerrainForRiver(originalTerrain: TerrainType): TerrainType {
    // Convert terrain to river-compatible type
    if (originalTerrain === 'mountains') {
      return 'hills';
    }
    if (originalTerrain === 'desert') {
      return 'plains';
    }
    return originalTerrain; // Most terrains are fine
  }

  /**
   * Generate individual river from spring point using freeciv algorithm
   * @reference freeciv/server/generator/mapgen.c:792-851 make_river()
   */
  private makeRiver(
    startX: number,
    startY: number,
    tiles: MapTile[][],
    riverMap: RiverMapState,
    _riverType: RiverType
  ): boolean {
    let currentX = startX;
    let currentY = startY;
    const maxIterations = 100; // Prevent infinite loops
    let iterations = 0;

    while (iterations < maxIterations) {
      // Mark the current tile as river in rivermap (freeciv line 806)
      const tileIndex = currentY * this.width + currentX;
      riverMap.ok.add(tileIndex);

      // Test if the river is done (freeciv lines 812-820)
      if (this.isRiverComplete(currentX, currentY, tiles)) {
        return true; // River successfully completed
      }

      // Find next direction to continue the river (freeciv lines 822-851)
      const nextTile = this.findBestRiverDirection(currentX, currentY, tiles, riverMap);
      if (!nextTile) {
        return false; // River failed - got stuck
      }

      currentX = nextTile.x;
      currentY = nextTile.y;
      iterations++;
    }

    return false; // River failed - too many iterations
  }

  /**
   * Check if river is complete (reached water or existing river)
   * @reference freeciv/server/generator/mapgen.c:812-820
   */
  private isRiverComplete(x: number, y: number, tiles: MapTile[][]): boolean {
    // River ends if it connects to existing river
    const nearbyRivers = this.countRiverNearTile(x, y, tiles);
    if (nearbyRivers > 0) {
      return true;
    }

    // River ends if it reaches ocean - but only if the current tile is actually at the coast
    // Don't end just because ocean is nearby - rivers should be able to flow parallel to coast
    const currentTile = tiles[x][y];
    if (!this.isLandTile(currentTile.terrain)) {
      return true;
    }

    // River ends at poles (frozen terrain at high latitude - simplified)
    const frozen = currentTile.properties[TerrainProperty.FROZEN] || 0;
    if (frozen > 80) {
      return true;
    }

    return false;
  }

  /**
   * Find best direction for river continuation using freeciv test functions
   * @reference freeciv/server/generator/mapgen.c:826-851
   */
  private findBestRiverDirection(
    x: number,
    y: number,
    tiles: MapTile[][],
    riverMap: RiverMapState
  ): { x: number; y: number } | null {
    const cardinalDirs = [
      { dx: 0, dy: -1 }, // North
      { dx: 1, dy: 0 }, // East
      { dx: 0, dy: 1 }, // South
      { dx: -1, dy: 0 }, // West
    ];

    let bestDirection: { x: number; y: number; score: number } | null = null;

    // Test each cardinal direction
    for (const dir of cardinalDirs) {
      const nx = x + dir.dx;
      const ny = y + dir.dy;

      // Check bounds
      if (nx < 0 || nx >= this.width || ny < 0 || ny >= this.height) {
        continue;
      }

      // Run river test functions (simplified version)
      const score = this.calculateRiverDirectionScore(nx, ny, tiles, riverMap);
      if (score >= 0 && (!bestDirection || score < bestDirection.score)) {
        bestDirection = { x: nx, y: ny, score };
      }
    }

    return bestDirection;
  }

  /**
   * Calculate score for river direction (lower is better)
   * Simplified version of freeciv test_funcs
   */
  private calculateRiverDirectionScore(
    x: number,
    y: number,
    tiles: MapTile[][],
    riverMap: RiverMapState
  ): number {
    const tileIndex = y * this.width + x;

    // Blocked tiles get worst score
    if (riverMap.blocked.has(tileIndex)) {
      return 1000;
    }

    // Already marked as river
    if (riverMap.ok.has(tileIndex)) {
      return 500;
    }

    const tile = tiles[x][y];

    // Ocean tiles get good score (river mouth)
    if (!this.isLandTile(tile.terrain)) {
      return 10;
    }

    // Prefer lower elevation (less mountainous)
    const mountainous = tile.properties[TerrainProperty.MOUNTAINOUS] || 0;
    let score = mountainous;

    // Avoid dry terrain
    const dry = tile.properties[TerrainProperty.DRY] || 0;
    score += dry / 2;

    // Avoid frozen terrain
    const frozen = tile.properties[TerrainProperty.FROZEN] || 0;
    score += frozen / 2;

    return score;
  }

  /**
   * Generate river mask for connections
   */
  private generateRiverMask(
    x: number,
    y: number,
    tiles: MapTile[][],
    riverMap: RiverMapState
  ): number {
    let mask = 0;
    const tileIndex = y * this.width + x;

    // Mark as river tile
    riverMap.ok.add(tileIndex);

    // Check cardinal directions for connections
    const cardinalDirs = [
      { dx: 0, dy: -1, mask: 1 }, // North
      { dx: 1, dy: 0, mask: 2 }, // East
      { dx: 0, dy: 1, mask: 4 }, // South
      { dx: -1, dy: 0, mask: 8 }, // West
    ];

    for (const dir of cardinalDirs) {
      const nx = x + dir.dx;
      const ny = y + dir.dy;

      if (nx >= 0 && nx < this.width && ny >= 0 && ny < this.height) {
        const neighborTile = tiles[nx][ny];

        // Connect to existing rivers
        if (neighborTile.riverMask > 0) {
          mask |= dir.mask;
        }
        // Connect to ocean (river mouths)
        else if (!this.isLandTile(neighborTile.terrain)) {
          if (this.random() < 0.3) {
            // 30% chance to connect to ocean
            mask |= dir.mask;
          }
        }
        // Connect to suitable land tiles
        else if (this.isRiverSuitable(nx, ny, tiles)) {
          if (this.random() < 0.15) {
            // 15% chance to extend
            mask |= dir.mask;
          }
        }
      }
    }

    return mask;
  }

  /**
   * Check if a tile is suitable for river placement
   */
  private isRiverSuitable(x: number, y: number, tiles: MapTile[][]): boolean {
    const tile = tiles[x][y];

    // Prefer mountainous terrain
    const mountainous = tile.properties[TerrainProperty.MOUNTAINOUS] || 0;
    if (mountainous > 30) {
      return true;
    }

    // Avoid dry terrain unless it's near water
    const dry = tile.properties[TerrainProperty.DRY] || 0;
    if (dry > 70) {
      return this.isNearWater(x, y, tiles);
    }

    // Generally suitable for temperate terrain
    return tile.terrain === 'grassland' || tile.terrain === 'plains' || tile.terrain === 'forest';
  }

  /**
   * Check if tile is near water
   */
  private isNearWater(x: number, y: number, tiles: MapTile[][]): boolean {
    const radius = 2;
    for (let dx = -radius; dx <= radius; dx++) {
      for (let dy = -radius; dy <= radius; dy++) {
        const nx = x + dx;
        const ny = y + dy;
        if (nx >= 0 && nx < this.width && ny >= 0 && ny < this.height) {
          const terrain = tiles[nx][ny].terrain;
          if (!this.isLandTile(terrain)) {
            return true;
          }
        }
      }
    }
    return false;
  }

  /**
   * Check if terrain type is land (not water)
   */
  private isLandTile(terrain: TerrainType): boolean {
    return !['ocean', 'coast', 'deep_ocean', 'lake'].includes(terrain);
  }
}
